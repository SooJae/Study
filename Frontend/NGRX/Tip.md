# 리덕스로 해결할 수 있는 앵귤러에서 자주 일어나는 문제
리덕스는 외부 프로퍼티 문제를 해결할 수 있습니다.   
앵귤러의 관점에서 프로퍼티가 소외된다는 것은 무엇일까요?   
프로퍼티는 앵귤러 컴포넌트의 `@Input()` 멤버 변수와 동일합니다.

그래서 이것은 리덕스가 상황에 대처(cope with)할 수 있도록 도와준다는 것입니다.   
`@Input()`을 통해 입력을 전달하는 곳에서. 그러나 입력은 해당시점에서 적용되는 것이 아닌 외부에서 일어나는 것처럼 느껴집니다.    

예를 들어, 우리가 5~ 10 단계의 컴포넌트 트리에 값을 전송한다고 생각해봅시다.
트리의 잎(도착지의 컴포넌트)은 그것을 가지고 무엇을 해야 하는지 알고 있지만, 중간에 있는 모든 요소들(중간 컴포넌트)에 대해 입력은 외부의 값으로 느껴지며, 
그 요소들을 재사용하기 힘들도록 하고 어플리캐이션에 더 많이 묶이게 만든다. 그러나 그것은 단지 하나의 예일 뿐이다.

## 외부 프로퍼티는 무슨 의미가 있나요?
외부 프로퍼티 문제는 컴포넌트 간의 커뮤니케이션 문제로 보입니다.
컴포넌트가 컴포넌트 트리 안에 있는 완전히 다른 각각의 포인트에 의존했을때, 
입력정보를 트리 위로 10단계, 콜백 기능을 트리 아래로 10단계, 그리고 다른 가지 위로 5단계씩 전달하면 복잡도가 확장되지 않습니다.

이 상황이 발생하는 다른케이스를 보시죠.

- 트리 깊숙한 곳에 데이터를 전달하고, 컴포넌트 트리의 여러 단계에 반응합니다

- 또 다른 문제는 트리에 상호 의존적인 형제 컴포넌트가 있으며, 읽지 않은 메시지가 있는 폴더 목록 및 페이지 헤더의 전체 읽지 않은 메시지의 카운터와 같이 화면에 있는 동일한 데이터에 대해 다른 뷰를 나타냅니다.

더 많은 예시가 있습니다. 만약 우리가 @Input()을 이용하여 프로퍼티를 전달하면 더 빨리 이런 문제에 빠질 수 있습니다. 요소들에 입력만을 전달하는 것은 복잡성에서 확장되지 않습니다.
 
## 리액트가 유명한 이유?
아마도 외부 프로퍼티 이슈의 해결때문일 것입니다. 그것은 좀더 복잡한 컴포넌트의 상호작용이 일어나는 상황에서 해결책을 제공합니다.
이것은 우리가 더 큰 어플리케이션을 만들 수 없는 근본적인 문제였습니다. 그리고 Redux는 그것을 해결했습니다.
거의 모든 작지 않은 애플리케이션은 이러한 시나리오를 가지고 있으며, 
실제로는 대규모 응용프로그램이 필요하지 않으며, 대부분의 일반적인 엔터프라이즈 응용프로그램에는 복잡한 구성요소 간 통신 시나리오가 있습니다.

## 왜 리덕스가 이런 상황에서 동작을 잘 하는 걸까요?
만약 우리가 앵글러Js $scope.broadcast()와 같은 이벤트 버스를 통해 그러한 시나리오를 해결하려고 한다면, 우리는 이벤트 스프 시나리오로 쉽게 끝나게 될 것이며, 이벤트들은 예기치 못한 방식으로 스스로를 묶게 되고, 그 적용에 대해 이치를 따지기 어렵게 된다.

이것은 이벤트가 명령으로 매우 쉽게 전환되어 이미 수신기의 내부를 알 수 있기 때문입니다. 그리고 동시에 여러개의 체인 이벤트가 발생할 수 있습니다.

리덕스는 이벤트버스처럼 보이지만 아닙니다. 사실 리덕스 스토어는 커맨드와 옵저버블패턴의 조합입니다. 우리가 상점에서 하는 일은 액션이라고 알려진 명령 오브젝트로 보내는 것이다.
우리는 스토어에 액션을 디스패치 한다. 그리고 스토어는 스토어 안의 데이터에 대해 운영될 것이다.
그러나 액션의 Emitter는 스토어가 무엇을 하는지 알수 없다.

사용자는 또한 어플리케이션에서의 완전히 다른 부분으로 부터 온 또다른 액션을 dispatch 할 수 있다.

```js
store.dispatch({
    type: 'MARK_MESSAGE_AS_READ',
    payload: {
        messageId: 103
    }
});
```

스토어는 그것을 처리하고 메시지의 리스트를 업데이트 할 것이다. 그런다음 메시지가 필요한 어플리케이션으로 전송된다. 
그러나 수신의 끝은 무엇이 새로운 데이터의 생성을 촉발했는지 알지 못한다.

- 새로운 메시지가 백엑드로부터 도착
- 새로고침이 요청됨
- 읽은 메시지가 표시된다.

그렇다면 이것이 복잡성의 Decoupling과 확장과 무슨 관계가 있을까?

# 어떻게 스토어는 컴포넌트의 상호작용을 Decoupled할 수 있을까
데이터의 새로운 버전을 소비하는 컴포넌트( 예를 들어 메시지 리스트와 카운터 )는 우리가 RxJs옵저버블을 subscribe했을때와 같이 데이터가 변경되는 원인이 무엇인지 알지 못하며, 우리는 무엇이 값의 방출을 유발했는지 알지 못하며, 단지 새로운 값을 가지고 있다는 것만 알고 있다.
그 소비하는 컴포넌트들은 스토어에 자기자신들을 subscribe한다. 마치 그들이 RxJs 옵저버블을 구독하는 것처럼. 
이 패턴은 잘 동작한다. 왜냐하면 방출된 데이터를 명령으로 전환하기 위해 길을 벗어나야 하기 때문입니다. 반면에 이벤트 버스는 매우 쉽게 작동합니다.

# 서버 푸쉬는 어떤가요?
이제 서버도 끊임없이 새로운 데이터, 새로운 메시지를 푸쉬하고 있다고 하자. 데이터는 또한 다음 dispatch를 통해 푸시된다.

```js
store.dispatch({
    type: 'DISPLAY_NEW_MESSAGE',
    payload: {
        messageId: 104,
        userId: 3000,
        status: 'UNREAD',
        text: 'Hello World !'
    }
});
```

모든 케이스에서 새로운 메시지 리스트가 수신되고 메시지목록, 또는 읽지않은 메시지의 갯수로 렌더링됩니다.
렌더링의 결과는 다음과 같다. 우리는 모두 읽혀진 메시지 목록과 읽지 않은 메시지가 3개 있다는 카운터를 가지고 있지 않을 것이다. 
