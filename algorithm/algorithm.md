선택정렬 : 가장 작은 값을 앞으로 보낸다.
버블정렬 : 인접한 수와 비교후 바꾼다.
삽입정렬 : 왼쪽인덱스와 한칸씩만 비교 (왼쪽은 다 정렬되어있는 상태이므로) 
          왼쪽값이 더 크면 한칸 옆으로 이동합니다. (tmp 필요)

특정 인덱스 i에 대한 왼쪽 자식 노드의 i \* 2+1 에 해당되며 오른쪽 자식 노드는 i \* 2+2에 해당됩니다.
최대힙 성질을 만족하도록 트리를 조정해야합니다.
실제로는 가장 말단에 있는 것부터 해야 하지만, 마지막 ㄷ노드는 리프노드로 자식이 존재하지 않는다.
5/2=2인 2번 인덱스 부터 시작합니다.
https://lktprogrammer.tistory.com/70

Max-HEAPIFY는 자식을 가지는 마지막 노드부터 시작합니다. (length/2) 


Inorder
1. Left
2. Root
3. Right

Preorder
1. Root
2. Left
3. Right

Postorder
1. Left
2. Right
3. Root



## 그래프
방향이 있는 그래프 : Directed grapgh(트리)
방향이 없는 그래프
Cyclic 그래프, Acyclic 그래프        

그래프를 표현하는 방법
- Adjacency Matrix //표에 표현
- Adjacency List  // 배열에 표현


해시함수 : 특정한 규칙을 이용해 키값을 받아 해시코드로 전송합니다.

해시코드는 정수다. 배열 공간을 미리 만들어서 해시코드를 배열로 나누어서 담는다.
해시코드 자체가 배열의 인덱스로 사용되어서 인덱스를 구할 필요없이 다이렉트로 접근합니다.

그러나 해시함수를 이용하여 1,2,3번방에 10개의 값을 넣고자할때 1번방에만 10개를 넣고 2,3번방은 텅텅 비면 안되니까 이때 해시알고리즘을 사용합니다. (collision 방지)

O(1)~ O(n)

키(SooJae) -> 해시함수 -> 해시코드(3333) -> 인덱스 -> 저장

해시함수 알고리즘은 얼마나 잘 골고루 담느냐에 따라 성능을 평가 받는다.

다른 키 값으로 동일한 해시코드를 만든다. (키값은 문자열이고, 해시코드는 정수인데 정수가 제한되어있기때문에 )
해시함수가 서로 다른 해시코드를 만들었는데, 배열방이 한정되어있어서 같은 인덱스가 생성될 수 있다.


해시코드 예시
1. 키를 입력받는다.
2. 각 문자의 아스키코드를 더합니다. s(115)+j(106) = 221, m(109)+n(110) = 219
3. 고정된 배열방을 만든다 (3)
4. 221% 3 = 2에 저장 219%3 = 0
5. 그 후에 배열에 LinkedList를 만들어서 할당 될때마다 노드를 하나씩 붙여줍니다.


#깊이 우선 탐색(DFS : Depth First Search)

### 장점 
단지 현 경로상의 노드들만을 기억하면 되므로 **저장공간의 수요가 비교적 적다.**
목표노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있다.

### 단점
**해가 없는 경로에 깊이 빠질 가능성이 있다.** 따라서 실제의 경우 미리 지정한 임의의 깊이까지만 탐색하고 목표노드를 발견하지 못하면 다음의 경로를 따라 탐색하는 방법이 유용할 수 있다. 

얻어진 해가 최단 경로가 됩니다는 보장이 없다. 이는 목표에 이르는 경로가 다수인 문제에 대해 깊이우선 탐색은 해에 다다르면 탐색을 끝내버리므로, 이때 얻어진 해는 최적이 아닐 수 있다는 의미이다.

# DFS
깊이우선방식(inorder,preorder,postorder)
Stack 방식 
재귀함수를 이용하면 편하다

# BFS
너비 우선 탐색
Queue 방식

#TRIE
많은 양의 텍스트정보를 빠르고 효율적으로 검색하기 위해
그래서 Trie는 사전 혹은 인터넷 자동완성의 retrieval을 효과적으로 할 수 있는 자료구조이다.

