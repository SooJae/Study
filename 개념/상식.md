# 컴파일(Compile)

컴파일이란 개발자가 작성한 소스코드를 **바이너리 코드로 변환**하는 과정을 말합니다. (목적파일이 생성됨) 

즉, **컴퓨터가 이해할 수 있는 기계어로 변환**하는 작업입니다. 이러한 작업을 해주는 프로그램을 가르켜 컴파일러(Compiler)라 합니다.

자바의 경우, 자바가상머신(JVM)에서 실행가능한 바이트코드 형태의 클래스파일이 생성이 됩니다.


# 링크(link)
프로젝트를 진행하다 보면 소스파일이 여러개가 생성이되고 A라는 소스파일에서 B라는 소스파일에 존재하는 함수(메서드)를 호출하는 경우가 있습니다.

이때 A와 B 소스파일 각각을 컴파일만 하면 A가 B에 존재하는 함수를 찾질 못하기 때문에 호출할 수가 없다.

따라서 A와 B를 연결해주는 작업이 필요한데 이 작업을 링크라고 합니다.

여러개로 분리된 소스파일들을 컴파일한 결과물들에서 최종 실행가능한 파일을 만들기 위해 필요한 부분을 찾아서 연결해주는 작업입니다.

링크는 **정적링크(static link)** 와 **동적링크(dynamic link)** 가 있습니다.

### 정적링크 
컴파일된 소스파일을 연결해서 실행가능한 파일을 만드는 것
### 동적링크 
프로그램 실행 도중 프로그램 외부에 존재하는 코드를 찾아서 연결하는 것.

자바의 경우, JVM이 프로그램 실행 도중 필요한 클래스를 찾아서 클래스패스에 로드해주는데 이는 동적링크의 예입니다.


# 빌드(Build)

소스코드 파일을 **실행가능한 소프트웨어 산출물로 만드는 일련의 과정**을 말합니다. 

빌드의 단계 중 컴파일이 포함이 되어 있는데 **컴파일은 빌드의 부분집합**이라 할 수 있습니다.

빌드 과정을 도와주는 도구를 빌드 툴이라 합니다.

## 빌드 툴(Build Tool)

일반적으로 빌드 툴이 제공해주는 기능으로는 다음과 같은 기능들이 있습니다.

전처리(preprocessing), 컴파일(Compile), 패키징(packaging), 테스팅(testing), 배포(distribution)

빌드 툴로는 Ant, Maven, Gradle 등이 있습니다.


## JPA vs MYBATIS

Jpa 장점: 쿼리를 안만들어도 됩니다.
Jpa 단점: 복잡한 쿼리는 해결불가 (사실 이게 퍼포먼스 향상)

mybatis 장점: 복잡한 쿼리, 다이나믹 쿼리 이점
mybatis 단점: 비슷한 쿼리 남발 .


## 스택
- Heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당됩니다.
- 원시타입의 데이터가 값과 함께 할당됩니다.
- 지역변수들은 scope에 따른 visibility를 가진다.



출처: https://yeolco.tistory.com/94 [열코의 프로그래밍 일기]

# List와 Vector의 주요 차이점

1. 동기화(Synchronize)

Vector 동기화 O 
ArrayList 동기화 X

Vector는 한번에 하나의 스레드만 엑세스 O
ArrayList는 동시에 여러 스레드에 액세스 O

ArrayList에서 여러 스레드가 동시에 엑세스하는 경우 개발자가 명시적으로 동기화하는 코드를 추가해야합니다.


2. 스레드 안전(Thread Safe)
멀티 스레드 프로그래밍에서 여러 스레드가 동시에 접근이 이루어져도 프로그램 실행에 문제 X
앞서 말했듯이 Vector는 동기화 되어있기 때문에 한번에 하나의 스레드만 접근할 수 있기때문에 스레드가 안전.

ArrayList는 동기화되지 않았기 때문에 명시적으로 동기화 할 필요가 있습니다.

3. 성능

ArrayList는 동기화 되지않았기 때문에 동기화 된 벡터보다 더 빠르다.

4. 크기 증가

Vector와 ArrayList 모두 동적 배열 클래스로 최대 인덱스를 초과할 때 추가되는 인덱스 수가 다르다.
Vector는 현재 배열의 크기의 100%가 증가하며, ArrayList의 경우 현재 배열의 크기의 50%가 증가합니다.

멀티스레드 환경이 아닌 경우 ArrayList를 사용하는것이 바람직하다.

Vector를 사용하기 위한 명시적 요구 사항이 없는경우 ArrayList를 사용하자

# SOLID
## SRP (단일 책임 원칙, Single Reponsibility Principle)
작성된 클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든서비스는 그 하나의 책임을 수행하는데 집중되어야 합니다는 원칙.
SRP원리를 적용하면, 무엇보다도 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임 변경으로의 연쇄작용에서 자유로워짐.
객체지향 원리의 대전제 격인 OCP원리 뿐만 아니라 다른 원리들을 적용하는 기초가 됩니다.

2
.
적용: 여러 원인에 의한 변경(Divergent change) : Extract Class를 통해 혼재된 각 책임을 각각의 개별 클래스로 분할하여 클래스 당 하나의 책임만을 맡도록 합니다.
여기서 관건은 책임만 분리하는 것이 아니라 



.
JVM이란?
출처 : https://asfirstalways.tistory.com/158
JVM이란 JAVA Virtual Machine, 자바 가상 머신의 약자를 따서 줄여 부르는 용어입니다.
JVM 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어들여 자바와 API와 함께 실행하는 것 입니다. 그리고 JVM은 JAVA와 OS사이에서 중개자 역할을 수행하여 JAVA가 OS에 구애받지 않고 재사용을 가능하게 해줍니다.
가장 중요한
- 메모리관리
- Garbage collection을 수행
그리고 JVM은 스택기반의 가상머신입니다. ARM 아키텍쳐같은 하드웨어는 레지스터 기반으로 동작하는데 JVM은 스택기반으로 동작합니다.
메모리 효율성을 위해 메모리 구조를 잘 알아야합니다. 메모리 관리가 되지않는 경우 속도저하 현상이나 튕김 현상등이 일어날 수 있습니다.

## 자바 실행과정

1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로하는 메모리를 할당 받습니다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리합니다.
2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
3. Class Loader를 통해 class파일들을 JVM으로 로딩합니다.
4. 로딩된 class 파일들은 Execution engine을 통해 해석됩니다.
5. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게 됩니다.
이러한 실행과정 속에서 JVM에 따라 Thread Synchronization과 GC같은 관리작업을 수행합니다.

#JVM 구성
## Class Loader 
JVM내로 클래스를 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈입니다. Runtime시에 동적으로 클래스를 로드합니다. jar파일 내 저장된 클래스들은 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제합니다.(컴파일러 역할) **자바는 동적코드, 컴파일 타임이 아니라 런타임**에 참조합니다. 즉, 클래스를 처음으로 참조할 때, **해당 클래스를 로드하고 링크**합니다는 것 입니다. 그 역할을 클래스 로더가 수행합니다.

## Execution Engine(실행 엔진)
**클래스를 실행시키는 역할**입니다. 클래스 로더가 JVM 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 실행엔진에 의해 실행됩니다. 자바 **바이트코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것**입니다. 그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경합니다. 이때 두가지 방식을 사용합니다.

### Interpreter(인터프리터)
실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행합니다. 하지만 이 방식은 인터프리터 언어의 단점을 그대로 갖고있습니다. **한 줄씩 수행하기 때문에 느리다.**

### JIT(Just-In-Time)
인터프리터 방식의 단점을 보완하기 위해 JIT 컴파일러입니다. 인터프리터 방식으로 실행 하다가 적절한 시점에 **바이트코드 전체를 컴파일하여 네이티브 코드로 변경**하고, 이후에는 해당 더이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식입니다. **네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행**하게 됩니다.
물론 **JIT컴파일러가 컴파일하는 과정은 바이트코드를 인터프리팅 하는것보다 훨씬 오래걸리므로** 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅 하는 것이 유리하다. 따라서 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행합니다.

### Garbage collector

## Runtime Data Area

프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간

### PC Register
Thread가 시작될 때 생성되며 생성될 때마다 생성되는 공간으로 스레드마다 하나씩 존재합니다. Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행 중인 JVM 명령의 주소를 갖는다.

### JVM 스택영역
프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역입니다. 각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장합니다. 메소드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성됩니다. 메서드 수행이 끝나면 프레임 별로 삭제를 합니다. 메소드 안에서 사용되는 값들(local variable)을 저장합니다. 또 호출된 메소드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장합니다. 


### Native method stack
자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다. JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간입니다. JAVA Native Interface를 통해 바이트 코드로 전환하여 저장하게 됩니다. 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역입니다. 이 부분을 통해 C code를 실행시켜 Kernel에 접근할 수 있습니다.

1) Method Area (= Class area = Static area)
클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간. 올라가게 되는 메소드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드입니다. 자바 프로그램은 main 메소드의 호출에서부터 계속된 메소드의 호출로 흐름을 이어가기 때문입니다. 대부분 인스턴스의 생성도 메소드 내에서 명령하고 호출합니다. 사실상 컴파일 된 바이트코드의 대부분이 메소드 바이트코드이기 때문에 거의 모든 바이트코드가 올라갑니다고 봐도 상관없다. 이 공간에는 Runtime Constant Pool이라는 별도의 관리 영역도 함께 존재합니다. 이는 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행합니다.

올라가는 정보의 종류
1) Field Information
멤버변수의 이름, 데이터 타입, 접근 제어자에 대한 정보
2) Method Information
메소드의 이름, 리턴타입, 매개변수, 접근제어자에 대한 정보
3) Type Information
class인지 interface인지의 여부 저장 /Type의 속성, 전체 이름, super class의 전체 이름(interface 이거나 object인 경우 제외)

Method Area는 클래스 데이터를 위한 공간이라면 Heap영역이 객체를 위한 공간입니다.

Heap과 마찬가지로 GC의 관리 대상에 포함됩니다. 




5) Heap( 힙 영역 )
객체를 저장하는 가상 메모리 공간입니다. new연산자로 생성된 객체와 배열을 저장합니다. 물론 class area영역에 올라온 클래스들만 객체로 생성할 수 있습니다. 힙은 세 부분으로 나눌 수 있습니다.


Permanent Generation
생성된 객체들의 정보의 주소값이 저장된 공간입니다. Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용됩니다. Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용됩니다. 내부적으로 Reflection 기능을 자주 사용하는 Spring Framework를 이용할 경우 이영역에 대한 고려가 필요하다.

New/Young 영역
- Eden : 객체들이 최초로 생성되는 공간
- Survivor 0 / 1 : Eden에서 참조되는 객체들이 저장되는 공간

Old 영역
New area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간 Eden영역에 객체가 가득차게 되면 첫번째 GC(minor GC)가 발생합니다. Eden영역에 있는 값들을 Survivor 1 영역에 복사하고 이 영역을 제외한 나머지 영역의 객체를 삭제합니다.

인스턴스는 소멸 방법과 소멸 시점이 지역 변수와는 다르기에 힙이라는 별도의 영역에 할당됩니다. 자바 가상 머신은 매우 합리적으로 인스턴스를 소멸시킨다. 더이상 인스턴스의 존재 이유가 없을 때 소멸시킨다. 

출처 : https://asfirstalways.tistory.com/158

가비지 컬렉터
https://d2.naver.com/helloworld/329631


Java GC는 GC 대상 객체를 찾고, 대상 객체를 처리(finalization)하고, 할당된 메모리를 회수하는 작업으로 구성됩니다.
애플리케이션은 사용자 코드에서 객체의 reachability를 조절하여 Java GC에 일부 관여할 수 있습니다.
객체의 reachability를 조절하기 위해서 java.lang.ref 패키지의 SoftReference, WeakReference, PhantomReference, ReferenceQueue 등을 사용합니다.
.



메모리의 구조
프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(load)되어야 합니다.

또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요합니다.

 

따라서 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 있습니다.

프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 다음과 같습니다.

 

1. 코드(code) 영역

2. 데이터(data) 영역

3. 스택(stack) 영역

4. 힙(heap) 영역

 


C언어 메모리 구조


![abc](memory_structure.png)


자바 메모리 구조


![](img_java_memory_structure.png)


## 메소드(method) 영역
메소드(method) 영역은 자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역입니다.

JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장합니다.

## 힙(heap) 영역
힙(heap) 영역은 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역입니다.

JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장합니다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

## 스택(stack) 영역
스택(stack) 영역은 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역입니다.

 

JVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장합니다.

이렇게 스택 영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸합니다.

이렇게 스택 영역에 저장되는 메소드의 호출 정보를 스택 프레임(stack frame)이라고 합니다.

 

스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.

이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.

스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.
