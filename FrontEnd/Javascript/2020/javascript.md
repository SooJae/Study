# 식별자
변수 이름을 식별자라고도 한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 변수, 함수, 클래스등 이름은 모두 식별자이다.

# 자바스크립트 엔진
자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다.
1. 선언단계: 변수를 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

# 문과 표현식 
문(statement) : 프로그램을 구성하는 기본 단위이자 최소 실행 단위 이다.
토큰 : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

var(토큰) sum(토큰) =(토큰) 1(토큰) +(토큰) 2(토큰) < = 전체가 문
문을 명령문이라고도 부른다. 문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

## 표현식인 문 vs 표현식이 아닌 문
표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다.
예를 들어 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 
하지만 할당문은 값으로 평가될 수 있다. 따라서 표현식인 문이다.
표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 것이다.          
표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.
표현식인 문은 값으로평가되므로 변수에 할당할 수 있다. 하지만 아닌 문은 할당하면 에러가 발생한다.
p.57 참조 

# 호이스팅
코드가 한 줄씩 실행되는 시점 - 런타임, 인터프리터에 의해 한 줄씩 순차적으로 실행된다.
런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.       
함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를
암묵적으로 생성하고 생성된 함수 객체를 할당한다.     
즉, 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고, 함수 이름과 동일한 식별자에 할당까지 완료된 상태다.
이를 호이스팅 이라 한다.

함수 호이스팅 vs 변수 호이스팅
var 키워드로 선언된 변수는 undefined로 초기화 되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.
함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다.
변수 할당문의 값은 할당문이 실행되는 시점. 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.

# 함수
## 화살표 함수
화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다. 화살표 함수에 대해서는 먼저 생성자 함수,
this, 프로토타입, arguments 객체를 살펴보자.

```js
function add(x, y) {
  return x + y;
}
console.log(add(2,5,10)) // 7
```
10이 버려지는 것처럼 보이겠지만 2, 5, 1 0 모두 arguments 객체의 프로퍼티로 보관된다.

```js
function add(x, y) {
  console.log(arguments); // Arguments(3) [2, 5, 10, callee: f, Symbol(Symbol.iterator): f]
  return x + y;
}
console.log(add(2,5,10)) // 7
```

## 매개변수의 최대 개수
매개변수는 순서에 의미가 있다. 따라서 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다.
이는 함수의 사용법을 이해하기 어렵게 만들고 실수를 발생시킬 가능성을 높인다. 또한 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 형향을 받는다.
즉, 유지보수성이 나빠진다.

함수의 매개변수는 코드를 이해하는 데 방해되는 요소이므로 이상적인 매개변수 개수는 0개이며 적을수록 좋다. 매개변수의 개수가 많다는 것은 함수가 여러가지 일을 한다는 증거이므로 바람직하지 않다.
이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.<클린코드>(인사이트, 2013)

따라서 매개변수는 **최대 3개**이상 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 **객체를 인수로 전달하는 것이 유리**하다.
객체를 인수로 사용하는 경우, 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경 쓰지 않아도 된다.
하지만 주의할 것은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수효과(side effect)기 발생한다.

176p.

# 즉시 실행 함수
함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행함수(IIFE)라고 한다.
즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이다.
그룹연산자(...) 내의 기명함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 사용할 수 있는 식별자 이므로 즉시 실행함수를 다시 호출할 수 없다.

```javascript
(function foo() {
...
return true;
}()); 

foo() // ReferenceError: foo is not defined
```
178p.

## 콜백함수, 고차함수
**함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수**를 콜백 함수(callback function) 라고 하며, **매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수**를 고차 함수(Higher-Order Function)라고 한다.
중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 즉, 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다. 
다시 말해, 콜백 함수는 고차 함수에 의해 호출되며(모든 콜백 함수가 고차 함수에 의해 호출 되는 것은아니다. 예를 들어, setTimeout 함수의 콜백함수는 setTimeout 함수가 호출하지 않는다.) 이때 고차함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다. 따라서 고차함수에 콜백함수를 전달할때 콜백함수를 호출하지 않고 함수 자체를 전달해야 한다.
184p.


## 비 순수함수
```javascript
var count = 0;
```
187p.

# 스코프
## 식별자 결정
식별자 결정이란 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조해야 할 것인지를 결정해야 한다. 이를 식별자 결정이라 한다.
자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정한다. 따라서 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.
자바스크립트 엔진은 코드를 실행할 때 코드의 문맥을 고려한다. 코드가 어디서 싫애되ㅕ 주변에 어떤 코드가 있는지에 따라 

## 코드의 문맥과 환경
코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다.
즉, 코드의 문맥은 렉시컬 환경으로 이뤄진다. 이를 구현한 것이 실행 컨텍스트이며, 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.
스코프는 실행 컨텍스트와 깊은 관련이 있다.

렉시컬 환경
195p.

스코프를 `변수를 검색할 때 사용하는 규칙`이라고 표현하기보다는 **식별자를 검색하는 규칙**이라고 표현하는 편이 좀 더 적합하다.

## 렉시컬 스코프
1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다. (동적 스코프)
2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. (렉시컬 스코프 혹은 정적 스코프)

199p.

## 접근자 프로퍼티 vs  데이터 프로퍼티

```js
// 일반 객체의 __proto__는 접근자 프로퍼티다.
Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
// {enumerable: false, configurable: true, get: ƒ, set: ƒ}

// 함수 객체의 prototype은 데이터 프로퍼티다.
Object.getOwnPropertyDescriptor(function() {}, 'prototype');
// {value: {…}, writable: true, enumerable: false, configurable: false}
```

객체 변경 방지 229p.
인스턴스 생성시 this 241p

## 함수 객체 vs 일반 객체
함수는 객체이지만 일반 객체와는 다르다. **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.** 따라서 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론 함수로서 동작하기 위해 함수 객체만을 위한
`[[Environment]]`, `[[FormalParameters]]` 등의 내부 슬롯과 `[[Call]]`, `[[Construct]]` 같은 내부 메서드를 추가로 가지고 있다.
함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 `[[Call]]`이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 `[[Constructor]]`가 호출된다.
242p.


## 커링 함수
https://stackoverflow.com/questions/32782922/what-do-multiple-arrow-functions-mean-in-javascript

# 일급 객체
다음을 일급 객체라 한다.
1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환 값으로 사용할 수 있다.
  
